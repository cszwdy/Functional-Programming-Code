<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Section 33</title>
  <meta id="xcode-display" name="xcode-display" content="render">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, maximum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<div class="content-wrapper">
  <section class="section">
    <p>In the first case, we pass both arguments to <code>add1</code> at the same time; in
the second case, we first pass the first argument, <code>1</code>, which returns a
function, which we then apply to the second argument, <code>2</code>. Both versions
are equivalent: we can define <code>add1</code> in terms of <code>add2</code>, and vice versa.</p>
<p>In Swift, we can even leave out one of the return statements and some of
the parentheses in the type signature of <code>add2</code>, and write:</p>
<pre><code>func add2(x: Int) -&gt; Int -&gt; Int {
    return { y in x + y }
}
</code></pre><p>The function arrow, <code>-&gt;</code>, associates to the right. That is to say, you
can read the type <code>A -&gt; B -&gt; C</code> as <code>A -&gt; (B -&gt; C)</code>. Throughout this
book, however, we will typically introduce a type alias for functional
types (as we did for the <code>Region</code> and <code>Filter</code> types), or write explicit
parentheses.</p>
<p>The <code>add1</code> and <code>add2</code> examples show how we can always transform a
function that expects multiple arguments into a series of functions that
each expect one argument. This process is referred to as <em>currying</em>,
named after the logician Haskell Curry; we say that <code>add2</code> is the
<em>curried</em> version of <code>add1</code>.</p>
<p>There is a third way to curry functions in Swift. Instead of
constructing the closure explicitly, as we did in the definition of
<code>add2</code>, we can also define a curried version of <code>add1</code> as follows:</p>

  </section>
</div>
</body>
</html>
